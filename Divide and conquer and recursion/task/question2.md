## 2-9 设子数组a[0:k-1]和a[k:n-1]已经排好序。设计一个合并这两个子数组为排好序的数组a[0:n-1]的算法。要求算法在最坏情况下所用的计算时间为O(n)，且只用到O(1)的辅助空间。
**我们可以声明一个a[n]用来存储目标数组;我们只需要将其中一个数组存放其中,例如将a1[0:k-1] 存放在前k项,声明三个指针,分别指向两个子数组的尾部,目标数组的尾部;从后往前依次比较,将较大的数放到目标数组的尾部,较大的指针也往前移即可,目标数组尾部指针也向前移;直至p1,p3重合结束;**

## 2-12 试证明，在最坏情况下，求n个元素组成的集合S中的第k小元素至少需要n+min(k, n-k+1)-2次比较。
**下面证明第k小元素问题的时间下界，由于要确定下界，不失一般性，可设集合S中的所有元素互不相同，要确定第k小元素z，就要确定S中的其他元素与z的关系，基于比较的算法中，可以通过三种方式确定某一元素与z的关系，1、该元素与z比较，便可确定其与z的大小关系；2、该元素比一个确定比z大的元素大，则该元素比z大；3、该元素比一个确定比z小的元素小，则该元素比z小，这三种比较称为关键比较，由于集合中有n个元素，所以至少需要n-1c次关键比较，才能确定集合中的第k小元素。
同时，基于比较的算法过程中还剩余两种无用比较，即某一元素，1、该元素比大于z的元素小；2、该元素比小于z的元素大，这两种情况我们无法确定该元素与z的关系，得不到有用信息，为无用比较，为降低算法时间复杂度，减少比较次数，我们希望尽可能的多做关键比较，少做无用比较，而所谓对手策略，便是迫使我们尽量多得做无用比较，以获取尽量大的T（A，I’），即最坏情况。在算法执行的任何阶段，集合中的元素有以下三种状态：
1、L——该元素的值已确定大于z  
2、M——该元素的值已确定小于z  
3、N——该元素的值不确定  
所以每当算法做两个元素x和y的比较时，对手策略根据x和y的状态，按照下表确定状态为N的元素的值  
x     y     对手策略   
N    N    x取值大于z，y取值小于z  
N    L     x取值小于z  
L     N    y取值小于z  
N    S     x取值大于z  
S    N     y取值大于z  
对手策略中的每个比较均为非关键比较每个这类比较最多产生一个元素状态L或S，算法最终产生k-1个状态为S的元素和n-k个状态为L的元素，因此，上述对手策略至少迫使产生做了min(k-1，n-k)次非关键比较（用你最好的算法去压制最坏的情况）。因此任何算法在求第k小元素上至少做了n-1+min(k-1，n-k)次比较。由此可见，在最坏情况下，第k小元素问题至少需要n-1+min(k-1，n-k)-次比较，即n+min(k，n-k+1)-2次比较。  
当n是奇数时，集合S的中位数是（n+1）/2小元素，由上述结论可知。3n/2-3/2是中位数问题的一个计算时间下界.**  


 


## 2-5 有重复元素的排列问题：

*问题描述：设R={r1, r2, …, rn}是要进行排列的n个元素，其中元素r1, r2, …, rn可能相同。试设计一个算法，列出R的所有不同排列。  

**算法设计：给定n及待排列的n个元素，计算出这n个元素的所有不同排列**  
```
#include<iostream>
using namespace std;
char str[1000];//存放排列的数组
int ans=0;//记录次数
int k[1000][2];//存放字符与次数
int n;//记录元素个数
void dfs(int depth)
{
    if(depth==n)//输出
    {
        ans++;//记录次数
        for(int i=0;i<n;i++)//输出排列
        cout<<str[i];
        cout<<endl;
        return;//结束搜索
    }
    else{
        for(int i=0;i<n;i++)
        {
            if(k[i][1]!=0)//若是有元素没排列过,进行排列
            {
                str[depth-1]=(char)k[i][0];
                k[i][1]--;
                dfs(depth+1);
                k[i][1]++;//注意回溯
            }
        }
    }
}
```