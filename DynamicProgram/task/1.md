算法实现题2

2-11 整数因子分解问题：

问题描述：大于1的正整数n可以分解为n = x1\* x 2\* …\* x n。例如，当n =12时，有8种不同的分解式：

12=12      ;          12=3\*2\*2

12=6\*2       ;       12=2\*6

12=4\*3        ;      12=2\*3\*2

12=3\*4       ;       12=2\*2\*3

算法设计：对于给定的正整数n，计算n共有多少种不同的分解式。  
解答:
我们可以先将正整数分解为一个因子,再将这个因子分解成两个因子,再分别对两个因子继续分解,直到因子不能继续分解为止;最后将所有的答案汇总形成解;
```
void f(int x)//列出这个因子的所有分解结果
{
    int i=2;
    while(i<x)//先找出第一个因子,并进行下一步规划
    {
        if(x%i==0)
        {
            cout<<i<<'*';
            f(x/i);
        }
        i++;
    }
    cout<<i<<endl;//这个因子为本身则结束规划
}
```
 

算法分析题3

3-1 设计一个O($n^2$)时间的动态规划算法，找出由n个数组成的序列的最长单调递增子序列。
例如，设L=｛a1,a2,…,an｝是n个不同实数构成的序列，L的递增子序列是指这样子序列：L1=｛ak1,ak2,…,akm｝，其中k1<k2<…<km且ak1<ak2<…<akm。即子序列中的元素接升序排列，但不一定是L中连续的元素。  
解答:  
我们可以设计一个动态规划算法,将问题分解为每个元素作为起点时,组成的最长递增子序列;我们可以声明一个f[i]来存储在以位置i结尾的最长的递增序列,求f[i]时我们只需要考虑之前的元素小于a[i],我们遍历下找出最大长度并保存;最后就可以找出最大长度了;若是我们需要记录序列元素,只需要用两个数组来记录即可;


