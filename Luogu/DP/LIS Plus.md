## 题意：
给你一个长度为n的序列a1,a2,...,an，你需要把这n个元素分成三类：1，2，3：

1:所有的最长上升子序列都不包含这个元素

2:有但非所有的最长上升子序列包含这个元素

3:所有的最长上升子序列都包含这个元素

## 输入格式：
第一行包含一个正整数n，表示序列的长度。第二行包含n个正整数a1,a2,...,an，表示序列中的元素。

## 输出格式：
一行，包含一个长度为n的、由1,2,3三种数字组成的字符串，第i个数字表示ai所属类别。

## 数据范围：
1≤n≤$10^5$

1≤ai≤$10^5$

## 输入输出样例   
输入 1  4  
输出   3   
输入  4  1 3 2 5  
输出  3223  
输入  4  1 5 2 3  
输出  3133  


## 解法
我们可以采用LIS的第二种解法,对其改进,增加追踪变量;确定每个最长上升序列的每个元素;  
参考:
```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#define maxn 100005
using namespace std;
int n,a[maxn];//整个序列
int dp[maxn];//dp[i]代表当前长度为i的上升子序列末尾元素的最小值
int len=0;//整个序列LIS的长度
int sign[maxn];//序列元素所属类别
vector<int>layer[maxn];//分层数组，一共有len层。layer[i]中的点表示这些元素：以这些元素结尾的最长上升子序列长度为i
inline int bins(int i,int val){
    int l=0,r=layer[i].size()-1;
    while(l<r){
        int m=(l+r)>>1;
        if(a[layer[i][m]]>=val)l=m+1;
        else r=m;
    }
    return l;
}
int main(){
    scanf("%d",&n);
    memset(dp,0x3f,sizeof(dp));
    dp[0]=0;
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        int length=lower_bound(dp,dp+n+1,a[i])-dp;//O(nlogn)求LIS
        dp[length]=min(dp[length],a[i]);
        //length表示以该元素结尾的最长上升子序列的长度
        layer[length].push_back(i);//加入到分层数组
        len=max(len,length);//更新整个序列的LIS长度
    }
    for(int i=1;i<=n;i++)sign[i]=1;//初始化全都为第1类，即任何LIS都不经过它们
    if(layer[len].size()==1)sign[layer[len][0]]=3;
    else for(int i=0;i<layer[len].size();i++)sign[layer[len][i]]=2;
    for(int i=len;i>=2;i--){//倒序处理分层数组，一层一层往前推
        for(int j=0;j<layer[i].size();j++){//枚举当前层的所有点
            int bh=layer[i][j];//点的编号
            if(sign[bh]>1){//如果当前节点可以向前扩展（存在LIS经过当前点）
                int l=bins(i-1,a[bh]);//二分查找，扩展的节点在序列中的值必须小于当前节点，才能保证LIS严格递增
                int r=lower_bound(layer[i-1].begin(),layer[i-1].end(),bh)-layer[i-1].begin()-1;//二分查找，扩展的点编号必须小于当前点编号，才能是“序列”
                //当前点可扩展到的前一层的点的范围是区间[l,r]
                for(int k=l;k<=r;k++)sign[layer[i-1][k]]=2;//打上标记，该节点能够被扩展到说明一定在整个序列中有某个LIS包含该点
            }
        }
        //当前层能够扩展到的前一层的点是当前层所有点能扩展到的前一层的节点的并集
        int cnt=0,pos=0;
        for(int j=0;j<layer[i-1].size();j++)if(sign[layer[i-1][j]]==2){
            cnt++;
            pos=j;
        }
        if(cnt==1)sign[layer[i-1][pos]]=3;//如果该层所有可扩展的点只能在前一层中扩展出一个节点，说明这个节点是所有LIS的必经节点。
    }
    for(int i=1;i<=n;i++)printf("%d",sign[i]);//不留空格打印
    return 0;
}
```
**有个重要的规律,a[i]要是某一LIS的元素,必须满足dp[dplength-1]=a[i]**  
演示:
a[]: 19 11 10 7 8 9 17 18 20 4 3 15 16 1 5 14 6 2 13 19  
dp[] :  
19  ; 19  ; v[1]:19*
11  ; 11  ; v[1]:19 11*    
10  ; 10  ; v[1]:19 11 10*  
7   ; 7   ; v[1]:19 11 10 7*  
7 8 ; 8   ; v[2]:0  0  0  8  
7 8 9  ; 9 ; v[3]:0  0  0  9 
7 8 9 17  ; 17 ; v[4]:0  0  0  17  
7 8 9 17 18  ; 18 ;v[5]:0  0  0  18  
7 8 9 17 18 20 ; 20; v[6]:0 0 0 20  
4 8 9 17 18 20  ; 4 ;v[1]:19 11 10 7 4*  
3 8 9 17 18 20  ; 3 ;v[1]:19 11 10 7 4 3*  
3 8 9 15 18 20  ;15 ;v[4]:0 0 0 17 0 15  
3 8 9 15 16 20  ; 16;v[5]:0  0  0 18 0 16  
1 8 9 15 16 20  ; 1 ;v[1]:19 11 10 7 4 3 1*  
1 5 9 15 16 20  ; 5 ;v[2]:0  0  0 8 0 0  5  
1 5 9 14 16 20  ; 14 ;v[4]:0 0 0 17 0 15 14  
1 5 6 14 16 20  ; 6; v[3]:0  0  0  9 0 0 6  
1 2 6 14 16 20  ; 2 ;v[2]:0  0  0 8 0 0  5 2*  
1 2 6 13 16 20  ;13 ;v[4]:0 0 0 17 0 15 14 13  
1 2 6 13 16 19  ;19 ;v[6]:0 0 0 20 0 0  0  19  
v[6]:0  0  0  20  0  0   0  19 
v[5]:0  0  0  18  0  16  0  0
v[4]:0  0  0  17  0  15  14 13 
v[3]:0  0  0  9   0  0   6  0
v[2]:0  0  0  8   0  0   5  2  
v[1]:19 11 10 7   4  3   1  0
遍历:
v[6]--v[1]  
19--16--15--9--8--7  
19--18--17--9--8--7  
20--18--17--9--8--7  
-->19 11 10 7 8 9 17 18 20 4 3 15 16 1 5 14 6 2 13 19
-->1  1  1  3 3 3 2  2  2  1 1 2  2  1 1 1  1 1 1  2  
形成代码:(会不会超时)